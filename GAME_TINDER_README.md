# ðŸ•¹ï¸ Tinder Game Mode - Architecture & Logic

This document explains the inner workings of the "Tinder for Plex" game engine implemented in `libs/session`.

## 1. Core Concept
The goal is to reach a **Consensus** (Match) as fast as possible with **Zero Friction**.

- **The Deck:** A shared list of 50 movies generated by the Host.
- **The Action:** Swipe Right (Like) or Left (Pass).
- **The Win Condition:** A movie is "Matched" when **ALL** participants in the session have Liked it.

## 2. Data Structure (Polymorphism)

Instead of rigid tables, we use a flexible Event Sourcing-like approach.

### GameSession
The container for the game.
- `code`: Short code (e.g. `A4Z9`) for easy sharing.
- `movieIds`: The Deck (Array of Strings).
- `participants`: List of Users joined.

### GameAction
Every move is stored as an immutable action.
```json
{
  "userId": "user_123",
  "type": "SWIPE",
  "payload": {
    "movieId": "movie_xyz",
    "liked": true
  }
}
```
*Why?* If we want to add a "SuperLike" or "Veto" later, we just add a new Action Type without changing the DB schema.

## 3. The Game Engine (`TinderGameStrategy`)

The logic is decoupled from the API. It's a pure function:
`State + New Action -> New State`

**Logic Flow:**
1. User swipes.
2. Engine counts the number of `SWIPE` actions with `liked: true` for this `movieId`.
3. **IF** `Count(Likes) >= Count(Participants)`:
   - **MATCH FOUND!**
   - `gameState.isGameOver = true`
   - `gameState.winnerMovieId = movie_xyz`

## 4. Real-Time Events (WebSockets)

The API uses Socket.io to push updates instantly.

- `participant_joined`: Sent when a guest uses the Join API.
- `match_found`: Sent immediately when the Engine detects a win.

## 5. Security & Auth
- **Host:** Needs a full account (to access Plex).
- **Guest:** Can be Anonymous (Guest User) or Authenticated.
- The system validates that the user `swiping` is indeed part of the `participants` list.

